<!DOCTYPE html>
<html lang='en' data-theme='dark'>
<head>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'/>
    <meta charset='utf-8'/>
    <style type='text/css'>
[data-theme='dark'] {                   /* color theme dark */
    --background: #121212;                                /* background (0dp elevation surface) */
    --surface: rgba(255, 255, 255, 0.05);                 /* surface (1dp elevation surface) */
    --primary: #bb86fc;                                   /* primary color */
    --secondary: #03dac6;                                 /* secondary color */
    --error: #cf6679;                                     /* error */
    --warning: #fdda0d;                                   /* warning */
    --onbackground: #ffffff;                              /* on background */
    --onsurface: #ffffff;                                 /* on surface */
    --onprimary: #000000;                                 /* on primary */
    --onsecondary: #000000;                               /* on secondary */
    --onerror: #000000;                                   /* on error */
    --textnormal: 0.6;                                    /* normal text (60% opacity) */
    --keypressed: #bb86fc;                                /* active soft key */
    --dbgbckgrnd: #343434;                                /* debugger background */
    --dbgcolor: #9594a3;                                  /* debugger color */
    --dbghilight: #575757;                                /* debugger selected line */
    --dbgborder: #707070;                                 /* debugger border */
}
[data-theme='light'] {                  /* color theme light */
    --background: #ffffff;
    --primary: #6200ee;
    --secondary: #00d7c3;
    --error: #b00020;
    --warning: #8b8000;
    --onbackground: #000000;
    --onsurface: #000000;
    --onprimary: #ffffff;
    --onsecondary: #000000;
    --onerror: #ffffff;
    --keypressed: #bb86fc;
    --dbgbckgrnd: #fafafa;
    --dbgcolor: #000000;
    --dbghilight: #d7d7d7;
    --dbgborder: #707070;
}
[data-theme='light'] .surface {
    box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.05);
}
@font-face { font-family: 'CP437'; src: url('../../emu/github/emu8/cp437.ttf'); }
@font-face { font-family: 'VT220'; src: url('../../emu/github/emu8/Glass_TTY_VT220.ttf'); }
body {                                  /* base */
    font-family: Ubuntu Mono, Monaco, Courier, monospace; /* font */
    font-size: 14px;                                      /* font size */
    background-color: var(--background); color: var(--onbackground);
}
input[type='checkbox'] {                /* check box */
    accent-color: var(--primary);
}
.command, input::file-selector-button { /* action elements style */
    padding: 5px 15px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
}
.button, input::file-selector-button {  /* buttons style */
    font-size: inherit; border: none; border-radius: 3px;
    background-color: var(--primary); color: var(--onprimary);
}
.tabbed {                               /* tab component */
    overflow-x: hidden; margin: -12px 0; padding-bottom: 10px;
}
.tabbed [type='radio'] { display: none; }
.tabs {
    padding: 0px 0px;                                     /* tab bar height (first number) */
    display: flex; align-items: stretch; list-style: none; background-color: var(--surface);
}
.tab > label {
    display: block; margin-bottom: -1px; cursor: pointer; opacity: var(--textnormal);
}
.tab-content {
    padding: 10px;                                        /* tab content padding */
    display: none; background-color: var(--surface); opacity: var(--textnormal);
}
.tabbed [type="radio"]:nth-of-type(1):checked ~ .tabs .tab:nth-of-type(1) label,
.tabbed [type="radio"]:nth-of-type(2):checked ~ .tabs .tab:nth-of-type(2) label,
.tabbed [type="radio"]:nth-of-type(3):checked ~ .tabs .tab:nth-of-type(3) label,
.tabbed [type="radio"]:nth-of-type(4):checked ~ .tabs .tab:nth-of-type(4) label,
.tabbed [type="radio"]:nth-of-type(5):checked ~ .tabs .tab:nth-of-type(5) label {
    border-bottom: 2px solid var(--primary); color: var(--primary);
}
.tabbed [type="radio"]:nth-of-type(1):checked ~ .tab-content:nth-of-type(1),
.tabbed [type="radio"]:nth-of-type(2):checked ~ .tab-content:nth-of-type(2),
.tabbed [type="radio"]:nth-of-type(3):checked ~ .tab-content:nth-of-type(3),
.tabbed [type="radio"]:nth-of-type(4):checked ~ .tab-content:nth-of-type(4),
.tabbed [type="radio"]:nth-of-type(5):checked ~ .tab-content:nth-of-type(5) {
    display: block;
}
.theme {                                /* theme switch */
    margin-left: auto;
}
.theme > button {
    font-size: 18px; border: none; background-color: inherit; color: var(--primary);
}
.jsShell {                              /* terminal component */
    height: 89vh; overflow: auto;
}
.cursor { background-color: var(--onbackground); border-right-color: var(--onbackground); }
.log_wnd {                              /* debugger window */
    border: 1px solid var(--dbgborder); padding: 8px; opacity: 1.0;
    background-color: var(--dbgbckgrnd); color: var(--dbgcolor);
}
.keyboard {
    background-color: #00000000; color: var(--onbackground); opacity: 1.0;
    margin-left: auto; margin-right: auto; padding: 5px; font-family: sans-serif;
    display: grid; grid-template-columns: auto auto;
}
.section {
    display: grid;
}
.key {
    grid-column: span 2;
    text-align: center; cursor: pointer;
    display: flex; flex-direction: column; align-items: center; justify-content: space-around;
    user-select: none;
}
.key:active { border-color: var(--keypressed); }
.key.i { font-size: 14px; font-weight: 600; }
.sp20 { grid-column: span 20; }
.sp5 { grid-column: span 5; }
.sp4 { grid-column: span 4; }
.sp3 { grid-column: span 3; }
.sp2 { grid-column: span 2; }
    </style>
    <script type='text/javascript'>
window.onerror = function(event, source, line, col, error) {
    const text = `Error: ${error.message} at ${source}:${line}:${col}`;
    document.write(`<span style="color: red;">${text}</span><br/>`);
};
    </script>
    <script src='../../emu/github/emu8/js/utils.js'></script>
    <script src='../../emu/github/emu8/js/monitor.js'></script>
    <script src='../../emu/github/emu8/js/emul.js'></script>
</head>
<body>
    <div class='tabbed'>
        <input type='radio' id='tab1' name='css-tabs' checked/>
        <ul class='tabs surface'>
            <li class='tab'><label class='command' for='tab1'>Terminal</label></li>
            <li class='theme'><button id='theme'>&#9770;</button></li>
        </ul>
        <div class='tab-content surface' id='terminal'></div>
    </div>
    <script type='text/javascript'>
'use strict';

/* jsShell.js | https://github.com/francoisburdy/js-shell-emulator */
class JsShell {
    constructor(container, max_length = 10000) {
        if (typeof container === 'string') {
            if (container.charAt(0) === '#') container = container.substring(1);
            container = document.getElementById(container);
        }
        this.containerNode = container;
        this.html = document.createElement('div');
        this.html.setAttribute('tabindex', 0);
        this.html.className = 'jsShell';
        this._innerWindow = document.createElement('div');
        this._output = document.createElement('pre');
        this._output.style.margin = '0';
        this._promptPS1 = document.createElement('span');
        this._inputLine = document.createElement('span');
        this._cursor = document.createElement('span');
        this._cursor.innerHTML = 'O';
        this._cursor.style.display = 'none';
        this._cursor.className = 'cursor';
        this._input = document.createElement('div');
        this._input.style.margin = '0';
        this._input.style.display = 'none';
        this._input.appendChild(this._promptPS1);
        this._input.appendChild(this._inputLine);
        this._input.appendChild(this._cursor);
        this._innerWindow.appendChild(this._output);
        this._innerWindow.appendChild(this._input);
        this.html.appendChild(this._innerWindow);
        this.containerNode.innerHTML = '';
        this.containerNode.appendChild(this.html);
        this.cursorSpeed = 500;
        this._shouldBlinkCursor = true;
        this.cursorTimer = null;
        this.setPrompt('');
        this._prms = {'_log': this._output, 'MAX_LENGTH': max_length};
    }
    setPrompt(promptPS) {
        this._promptPS1.innerHTML = promptPS;
        return this;
    }
    clear() {
        this._output.innerHTML = '';
        return this;
    }
    print(...args) {
        console.___log(this._prms, ...args);
        this.html.scrollTop = this.html.scrollHeight;
        return this;
    }
    write(message, color = null) {
        if (color) {
            const newLine = document.createElement('span');
            newLine.style.color = color;
            this._output.appendChild(newLine);
        }
        return this.print(message, console.NB);
    }
    printHTML(content) {
        const newLine = document.createElement('span');
        newLine.innerHTML = content;
        this._output.appendChild(newLine);
        return this.print();
    }
    _fireCursor() {
        if (this._shouldBlinkCursor) this._fireCursorInterval();
        else this._cursor.style.visibility = 'visible';
    }
    _fireCursorInterval() {
        if (this.cursorTimer) clearTimeout(this.cursorTimer);
        this.cursorTimer = setTimeout(() => {
            this._cursor.style.visibility = this._cursor.style.visibility === 'visible' ?
                    'hidden' : 'visible';
            this._fireCursorInterval();
        }, this.cursorSpeed);
    }
    async prompt(message = '') {
        return new Promise(async (resolve) => {
            const inputField = document.createElement('input');
            inputField.style.zIndex = '-100';
            inputField.style.outline = 'none';
            inputField.style.border = 'none';
            inputField.style.top = '0';
            inputField.style.opacity = '0';
            inputField.onblur = () => this._cursor.style.display = 'none';
            inputField.onfocus = () => {
                inputField.value = this._inputLine.textContent;
                this._cursor.style.display = 'inline-block';
            };
            inputField.onkeydown = e => {
                if (e.code === 'ArrowUp' || e.code === 'ArrowRight' || e.code === 'ArrowLeft' ||
                        e.code === 'ArrowDown' || e.code === 'Tab')
                    e.preventDefault();
                this._cursor.style.visibility = 'visible';
            };
            inputField.onkeyup = e => {
                this._fireCursor();
                const inputValue = inputField.value;
                if (e.keyCode === 13 || e.code === 'Enter') {
                    this._input.style.display = 'none';
                    this.printHTML(this._promptPS1.innerHTML + inputValue);
                    this.html.removeChild(inputField);
                    this.html.scrollTop = this.html.scrollHeight;
                    resolve(inputValue);
                }
                else this._inputLine.textContent = inputValue;
            };
            this.html.onclick = () => inputField.focus();
            this._inputLine.textContent = '';
            this._input.style.display = 'block';
            this.html.appendChild(inputField);
            this._fireCursor();
            if (message.length) this.printHTML(message);
            inputField.focus();
        });
    }
}

class SoftKbd {
    constructor(kbd_elem, con, con_elem = null) {
        this.fs_shift = false;
        this.fs_ctrl = false;
        this.fs_alt = false;
        this.fs_caps = false;
        const shfts = kbd_elem.getElementsByClassName('kshft'),
              ctrls = kbd_elem.getElementsByClassName('kctrl'),
              alts = kbd_elem.getElementsByClassName('kalt');
        kbd_elem.onclick = e => {
            let elem = e.target, tmp;
            if (elem.tagName === 'SPAN') elem = elem.parentNode;
            const key = elem.innerText.replace('\n', '');
            switch (this.trnCtrls(key)) {
                case 1:
                    this.fs_caps = !this.fs_caps; this.fs_shift = this.fs_caps;
                    tmp = this.fs_caps ? 'var(--keypressed)' : 'var(--onbackground)';
                    for (let i = 0; i < shfts.length; i++) shfts[i].style.borderColor = tmp;
                    break;
                case 2:
                    this.fs_shift = !this.fs_shift;
                    tmp = this.fs_shift ? 'var(--keypressed)' : 'var(--onbackground)';
                    for (let i = 0; i < shfts.length; i++) shfts[i].style.borderColor = tmp;
                    if (!this.fs_shift) this.fs_caps = false;
                    break;
                case 3:
                    this.fs_ctrl = !this.fs_ctrl;
                    tmp = this.fs_ctrl ? 'var(--keypressed)' : 'var(--onbackground)';
                    for (let i = 0; i < ctrls.length; i++) ctrls[i].style.borderColor = tmp;
                    break;
                case 4:
                    this.fs_alt = !this.fs_alt;
                    tmp = this.fs_alt ? 'var(--keypressed)' : 'var(--onbackground)';
                    for (let i = 0; i < alts.length; i++) alts[i].style.borderColor = tmp;
                    break;
                default:
                    this.kbdHandler({key}, true);
                    if (!this.fs_caps && this.fs_shift) {
                        for (let i = 0; i < shfts.length; i++)
                            shfts[i].style.borderColor = 'var(--onbackground)';
                        this.fs_shift = false;
                    }
                    if (this.fs_ctrl) {
                        for (let i = 0; i < ctrls.length; i++)
                            ctrls[i].style.borderColor = 'var(--onbackground)';
                        this.fs_ctrl = false;
                    }
                    if (this.fs_alt) {
                        for (let i = 0; i < alts.length; i++)
                            alts[i].style.borderColor = 'var(--onbackground)';
                        this.fs_alt = false;
                    }
                    break;
            }
        };
        document.onkeydown = e => {
            if (e.target !== this.kbd_elem) return;
            switch (e.key) {
                case 'Shift': this.fs_shift = true; break;
                case 'Control': this.fs_ctrl = true; break;
                case 'Alt': this.fs_alt = true; break;
            }
        };
        document.onkeyup = e => {
            if (e.target !== this.kbd_elem) return;
            switch (e.key) {
                case 'Shift': this.fs_shift = false; break;
                case 'Control': this.fs_ctrl = false; break;
                case 'Alt': this.fs_alt = false; break;
                default: this.kbdHandler(e, false); break;
            }
        };
        this.kbd_elem = kbd_elem;
        this.con = con;
        this.con_elem = con_elem;
    }
    kbdHandler(e, soft) {
        let conKey;                      // map key events from hrdw keyboard to sys menu
        if (!soft && e.target === this.con_elem && (conKey = this.checkConKey(e))) { // sys menu key?
            con_elem.onclick({'target': {'innerText': conKey}});                     // sys menu click
            return;
        }
        const val = this.translateKey(e, soft);
        if (val !== null) this.processKey(val);
    }
    trnCtrls(txt) {                      // soft CTRL, SHIFT and ALT processing
        return (txt === 'CapsLock') ? 1 : (txt === 'Shift') ? 2 : (txt === 'Ctrl') ? 3 :
                (txt === 'Alt') ? 4 : 0;
    }
    checkConKey(e) {
        if (!this.fs_alt) return null;   // map Alt+key
        switch (e.key) {
            case '=': return '\u2588';   // full screen mode
            case 'F11': return '\u25a6'; // soft keyboard switch
            case 'F12': return '\u25d0'; // contrast
        }
        return null;
    }
    translateKey(e, soft) {
        let val = null;
        switch (e.key) {
            case 'Escape': val = 27; break;
            case 'F1': case 'F2': case 'F3': case 'F4': case 'F5': case 'F6': case 'F7':
            case 'F8': case 'F9': case 'F10': case 'F11': case 'F12': break;
            case 'Backspace': val = 8; break;
            case 'Tab': val = 9; break;
            case 'Enter': val = 13; break;
            case '': case 'Space': val = 32; break;
            case 'Insert': val = 15; break;
            case 'PageUp': val = 18; break;
            case 'Delete': val = 127; break;
            case 'Home': case 'End': val = 2; break;
            case 'PageDown': val = 3; break;
            case 'ArrowLeft': val = 19; break;
            case 'ArrowUp': val = 5; break;
            case 'ArrowRight': val = 4; break;
            case 'ArrowDown': val = 24; break;
            default:
                if (e.key.length > 1) val = e.key.charCodeAt(this.fs_shift ? 0 : 1);
                else {
                    if (soft && !this.fs_shift) e.key = e.key.toLowerCase();
                    val = e.key.charCodeAt(0);
                }
                break;
        }
        if (val !== null) {
            val &= 0xff;
            if (this.fs_ctrl) {
                if (val >= 0x60) val -= 0x60;
                if (val >= 0x40) val -= 0x40;
            }
        }
        return val;
    }
    processKey(val) {
        this.con.kbd.push(val);
    }
}

const html_tag = document.querySelector('html');
document.getElementById('theme').onclick = e => {
    html_tag.setAttribute('data-theme',
            (html_tag.getAttribute('data-theme') === 'dark') ? 'light' : 'dark');
};

const URL_OPTS = new URLSearchParams(location.search),
      term = new JsShell('terminal', 1000);

let saved_wdx, saved_hgh;  // UI temp vars
const CREATED_STYLES = {}, // created css styles
      amber = '#b38000',   // amber monitor
      green = '#36bf00',   // green monitor
      blue = '#a5a4b3',    // blue (white) monitor
colorsVGA = (color, bckgr = '#282828') => [
    gSVar(bckgr), '#0000aa', '#00aa00', '#00aaaa', '#aa0000', '#aa00aa', '#aa5500', gSVar(color),
    '#555555', '#5555ff', '#55ff55', '#55ffff', '#ff5555', '#ff55ff', '#ffff55', '#ffffff'
],
createCon = async (canvas, color, font = 'CP437', width = 80, height = 24, bckgr = '#282828') => {
    let settings = {'COLORS': colorsVGA(color, bckgr)};
    if (font === 'VT220') settings = {...settings, 'FONT_WIDTH': 10, 'FONT_HEIGHT': 20, 'FONT_G0': 'VT220'};
    settings = {...settings, 'SCR_WIDTH': width, 'SCR_HEIGHT': height};
    return await VT_100(canvas, settings);
},
gSVar = str => {
    if (str.startsWith('var(')) {
        const p = getComputedStyle(document.body)
                .getPropertyValue(str.substring(4, str.length - 1));
        if (p) str = p.trim();
    }
    return str;
},
addTab = (id, name, num = 1) => {
    let elem = document.createElement('input');
    elem.setAttribute('type', 'radio');
    elem.setAttribute('id', id);
    elem.setAttribute('name', 'css-tabs');
    document.querySelector(`div.tabbed input:nth-of-type(${num})`).after(elem);
    elem = document.createElement('li');
    elem.className = 'tab';
    elem.innerHTML = `<label class='command' for='${id}'>${name}</label>`;
    document.querySelector(`div.tabbed ul li:nth-of-type(${num})`).after(elem);
    const res = document.createElement('div');
    res.className = 'tab-content surface';
    document.querySelector(`div.tabbed div:nth-of-type(${num})`).after(res);
    return res;
},
addStyle = txt => {
    const stl = document.createElement('style');
    stl.type = 'text/css'; stl.innerHTML = txt;
    document.head.appendChild(stl);
},
createUI = (
    tab,     // tab element to populate
	pf,      // css rule unique prefix
	pi,      // element id unique prefix
	ks,      // key size (string with units)
	nk,      // max keys in 1 row
	rs,      // keyboard rows
	br,      // key border radius (string with units)
	sw,      // screen width (string with units)
	sh,      // screen height (string with units)
	css,     // additional css fragment
	kbd,     // keyboard section(s) html fragment
	crs = 3, // system menu rows
	con = '' // system menu additional keys html fragment
) => {
    if (CREATED_STYLES[pf] === undefined) {
        addStyle(`
.kbd_${pf} { width: calc(${nk} * ${ks} / 2 + (${nk} - 2) * ${ks} / 10 + ${ks} / 2);
             grid-gap: calc(${ks} / 2); }
.sec_${pf} { grid-template-rows: repeat(${rs}, calc(${ks} / 1.36)); grid-gap: calc(${ks} / 10);
             grid-template-columns: repeat(${nk}, calc(${ks} / 2)); }
.key_${pf} { border: calc(${ks} / 30) solid var(--onbackground); border-radius: ${br}; }
.sec_${pf}_vert { grid-template-rows: repeat(${crs}, calc(${ks} / 1.36)); grid-gap: calc(${ks} / 10);
                  grid-template-columns: repeat(2, calc(${ks} / 2)); }
#scr_${pi} { width: ${sw}; height: ${sh}; margin: auto; display: block; }
#con_${pi} { position: absolute; opacity: 0.12; z-index: 100; width: 0px; }
#kbd_${pi} { opacity: 1.0; z-index: 50; }
${css}
        `);
        CREATED_STYLES[pf] = true;
    }
    tab.style.backgroundColor = 'var(--background)';
    tab.innerHTML = `
<canvas id='scr_${pi}'></canvas>
<div class='keyboard kbd_${pf}' id='kbd_${pi}'>${kbd}</div>
<div class='keyboard kbd_${pf}' id='con_${pi}'>
    <div class='section sec_${pf}_vert'>
        <div class='key i key_asr'>&#x2588</div>
        <div class='key i key_asr'>&#x25a6</div>
        <div class='key i key_asr'>&#x25d0</div>
${con}
    </div>
</div>
    `;
    const scr_elem = document.getElementById(`scr_${pi}`),
          kbd_elem = document.getElementById(`kbd_${pi}`),
          con_elem = document.getElementById(`con_${pi}`);
    con_elem['data-ks'] = ks;
    con_elem['data-scr'] = scr_elem;
    con_elem['data-kbd'] = kbd_elem;
    con_elem.onclick = conElm_click;
    updateElm(con_elem, true);
    screen.orientation.onchange = e => { setTimeout(() => updateElm(con_elem, true), 100); };
    return [scr_elem, kbd_elem, con_elem];
},
updateElm = (elem, top) => {
    let sw = window.innerWidth, sh = window.innerHeight, tp = '55px', gap = 25;
    if (document.fullscreenElement) {
        sw = screen.width; sh = screen.height; tp = '5px'; gap = 20;
    }
    if (top) { // set full screen toolbar
        elem.style.top = tp;
        elem.style.left = `${sw - gap - parseInt(elem['data-ks'])}px`;
    } else {   // set soft keyboard
        const rts = getComputedStyle(elem);
        elem.style.top = `${sh - parseInt(rts.height)}px`;
        elem.style.left = `${sw - parseInt(rts.width)}px`;
    }
},
conElm_click = async e => {
    let elem = e.target;
    if (elem.tagName === 'SPAN') elem = elem.parentNode;
    const txt = elem.innerText.replace('\n', '');
    elem = elem.parentNode.parentNode;
    const scr_elem = elem['data-scr'], kbd_elem = elem['data-kbd'];
    switch (txt) {
        case '\u2588': // enter/exit full screen mode
            if (document.fullscreenElement) {
                await document.exitFullscreen();
                scr_elem.style.width = saved_wdx; scr_elem.style.height = saved_hgh;
                kbd_elem.style.position = 'relative';
                kbd_elem.style.left = '0px'; kbd_elem.style.top = '0px';
                kbd_elem.style.display = 'grid';
                updateElm(elem, true);
            } else {
                saved_wdx = scr_elem.style.width; saved_hgh = scr_elem.style.height;
                await elem.parentNode.requestFullscreen();
                scr_elem.style.width = '100%';
                const ratio = parseInt(saved_wdx) / parseInt(saved_hgh);
                scr_elem.style.height = `${Math.min(screen.height, screen.width / ratio | 0)}px`;
                kbd_elem.style.position = 'absolute';
                updateElm(kbd_elem, false);
                updateElm(elem, true);
            }
            break;
        case '\u25a6': // show/hide keyboard
            const kbd_style = getComputedStyle(kbd_elem);
            kbd_elem.style.display = (kbd_style.display === 'none') ? 'grid' : 'none';
            break;
        case '\u25d0': // increase/decrease menu contrast
            let rstyle = getComputedStyle(kbd_elem), style = kbd_elem.style;
            if (rstyle.display === 'none') {
                rstyle = getComputedStyle(elem); style = elem.style;
            }
            switch (rstyle.opacity) {
                case '0.12': style.opacity = '0.25'; break;
                case '0.25': style.opacity = '0.5'; break;
                case '0.5': style.opacity = '0.75'; break;
                case '0.75': style.opacity = '0.85'; break;
                case '0.85': style.opacity = '1'; break;
                case '1': style.opacity = '0.12'; break;
            }
            break;
    }
};

console.error = console._logwrapper('var(--error)');
console.warn = console._logwrapper('var(--warning)');
console.info = console._logwrapper('var(--secondary)');

console._log = term._prms._log;             // merge terminal and
console.MAX_LENGTH = term._prms.MAX_LENGTH; // console

(async () => {
    try {
        await loadScript(URL_OPTS.get('js') ?? 'emu.js');
        await main();
    } catch(e) {
        console.error(e.stack);
    }
})();
    </script>
</body>
</html>
