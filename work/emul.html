<!DOCTYPE html>
<html lang='en'>
<head>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'/>
    <style type='text/css'>
@font-face { font-family: 'CP437'; src: url('../cp437.ttf'); }
@font-face { font-family: 'VT220'; src: url('../Glass_TTY_VT220.ttf'); }
html {
    --background: #121212;
    --onbackground: #808080;
    --keypressed: #bb86fc;   /* active soft key */
    --error: #ef2659;        /* log error */
    --warning: #adaa0d;      /* log warning */
    --info: #03aa56;         /* log info */
    --dbgbckgrnd: #343434;   /* debugger background */
    --dbgcolor: #9594a3;     /* debugger color */
    --dbghilight: #575757;   /* debugger selected line */
    --dbgborder: #707070;    /* debugger border */
}
body {
    font-family: Ubuntu Mono, Monaco, Courier, monospace; font-size: 14px;
    background-color: var(--background); color: var(--onbackground);
}
#scr {
    width: 800px; height: 480px;
    margin: auto; display: block;
}
.log_wnd {
    border: 1px solid var(--dbgborder); padding: 8px; opacity: 1.0;
    background-color: var(--dbgbckgrnd); color: var(--dbgcolor);
}
.keyboard {                     /* soft keyboard */
    --key_size: 36px;
    background-color: #00000000; color: var(--onbackground); opacity: 1.0;
    width: calc(36 * var(--key_size) / 2 + 34 * var(--key_size) / 10 + var(--key_size) / 2);
    margin-left: auto; margin-right: auto; padding: 5px; font-family: sans-serif;
    display: grid; grid-template-columns: auto auto; grid-gap: calc(var(--key_size) / 2);
}
.section {
    display: grid; grid-template-rows: repeat(6, calc(var(--key_size) / 1.36));
    grid-gap: calc(var(--key_size) / 10);
}
.section.left {
    grid-template-columns: repeat(30, calc(var(--key_size) / 2));
}
.section.right {
    grid-template-columns: repeat(6, calc(var(--key_size) / 2));
}
.key {
    border: calc(var(--key_size) / 30) solid var(--onbackground);
    border-radius: calc(var(--key_size) / 10); grid-column: span 2;
    font-size: calc(var(--key_size) / 3.5); text-align: center; cursor: pointer;
    display: flex; flex-direction: column; align-items: center; justify-content: space-around;
}
.key:active {
    border-color: var(--keypressed);
}
.key.i {                        /* icon key */
    font-size: 14px; font-weight: 600;
}
.sp20 { grid-column: span 20; } /* space */
.sp5 { grid-column: span 5; }   /* leftshift rightshift */
.sp4 { grid-column: span 4; }   /* backspace capslock enter */
.sp3 { grid-column: span 3; }   /* tab backslash leftctrl rightctrl */
.sp2 { grid-column: span 2; }   /* empty key */
    </style>
    <script type='text/javascript'>
window.onerror = function(event, source, line, col, error) {
    const text = `Error: ${error.message} at ${source}:${line}:${col}`;
    document.write(`<span style='color: red;'>${text}</span><br/>`);
};
    </script>
    <script src='../js/utils.js'></script>
    <script src='../js/jsZ80.js'></script>
    <script src='../js/disks.js'></script>
    <script src='../js/monitor.js'></script>
    <script src='../js/GSX.js'></script>
</head>
<body>
    <canvas id='scr'></canvas>
    <div class='keyboard'>
        <div class='section left'>
            <div class='key'>Esc</div><div class='key'>F1</div><div class='key'>F2</div>
            <div class='key'>F3</div><div class='key'>F4</div><div class='key'>F5</div>
            <div class='key'>F6</div><div class='key'>F7</div><div class='key'>F8</div>
            <div class='key'>F9</div><div class='key'>F10</div><div class='key'>F11</div>
            <div class='key'>F12</div><div class='sp2'></div><div class='sp2'></div>
            <div class='key'><span>~</span><span>`</span></div>
            <div class='key'><span>!</span><span>1</span></div>
            <div class='key'><span>@</span><span>2</span></div>
            <div class='key'><span>#</span><span>3</span></div>
            <div class='key'><span>$</span><span>4</span></div>
            <div class='key'><span>%</span><span>5</span></div>
            <div class='key'><span>^</span><span>6</span></div>
            <div class='key'><span>&</span><span>7</span></div>
            <div class='key'><span>*</span><span>8</span></div>
            <div class='key'><span>(</span><span>9</span></div>
            <div class='key'><span>)</span><span>0</span></div>
            <div class='key'><span>_</span><span>-</span></div>
            <div class='key'><span>+</span><span>=</span></div><div class='key sp4'>Backspace</div>
            <div class='key sp3'>Tab</div><div class='key'>Q</div><div class='key'>W</div>
            <div class='key'>E</div><div class='key'>R</div><div class='key'>T</div>
            <div class='key'>Y</div><div class='key'>U</div><div class='key'>I</div>
            <div class='key'>O</div><div class='key'>P</div>
            <div class='key'><span>{</span><span>[</span></div>
            <div class='key'><span>}</span><span>]</span></div>
            <div class='key sp3'><span>|</span><span>\</span></div>
            <div class='key sp4'>CapsLock</div><div class='key'>A</div><div class='key'>S</div>
            <div class='key'>D</div><div class='key'>F</div><div class='key'>G</div>
            <div class='key'>H</div><div class='key'>J</div><div class='key'>K</div>
            <div class='key'>L</div><div class='key'><span>:</span><span>;</span></div>
            <div class='key'><span>"</span><span>'</span></div><div class='key sp4'>Enter</div>
            <div class='key sp5 kshft'>Shift</div><div class='key'>Z</div><div class='key'>X</div>
            <div class='key'>C</div><div class='key'>V</div><div class='key'>B</div>
            <div class='key'>N</div><div class='key'>M</div>
            <div class='key'><span><</span><span>,</span></div>
            <div class='key'><span>></span><span>.</span></div>
            <div class='key'><span>?</span><span>/</span></div><div class='key sp5 kshft'>Shift</div>
            <div class='key sp3 kctrl'>Ctrl</div><div class='key kalt'>Alt</div>
            <div class='key sp20'>Space</div>
            <div class='key kalt'>Alt</div><div class='key sp3 kctrl'>Ctrl</div>
        </div>
        <div class='section right'>
            <div class='sp2'></div><div class='sp2'></div><div class='sp2'></div>
            <div class='key'>Insert</div><div class='key'>Home</div><div class='key'>PgUp</div>
            <div class='key'>Del</div><div class='key'>End</div><div class='key'>PgDn</div>
            <div class='sp2'></div><div class='sp2'></div><div class='sp2'></div>
            <div class='sp2'></div><div class='key i'>&#8593;</div><div class='sp2'></div>
            <div class='key i'>&#8592;</div><div class='key i'>&#8595;</div>
            <div class='key i'>&#8594;</div>
        </div>
    </div>
    <pre id='log'></pre>
    <script type='text/javascript'>
'use strict';

console.error = console._logwrapper('var(--error)');
console.warn = console._logwrapper('var(--warning)');
console.info = console._logwrapper('var(--info)');

class Cpu {
    constructor(memo, type) {
        this.CPU_INSTR_CNT = 10240; // ~8.4MHz for 8080 and Z80, ~4Mhz for 8086, ~12MHz for 6502
        this.HLT_STOP = true;       // stop CPU on HLT (must be false for MP/M)
        this.STOP = -1;             // stop address
        this.RUN = false;           // running
        switch (type) {
            case 0: this.cpu = new Cpu(memo); break;     // 8080
            case 1: this.cpu = createZ80(memo); break;   // Z80
            case 2: this.cpu = createN6502(memo); break; // 6502
            case 3:                                      // 8086
            case 4:                                      // 80186
                this.pic = new Intel8259();
                this.dma = new Intel8237();
                this.ppi = new Intel8255(this.pic);
                this.cpu = new Intel8086(memo.wr, memo.rd, this.pic, new Intel8253(this.pic), memo.int);
                this.cpu.peripherals.push(this.dma);
                this.cpu.peripherals.push(this.ppi);
                this.cpu.peripherals.push(new Intel8272(this.dma, this.pic));
                this.crtc = new Motorola6845();
                if (type === 4) {
                    this.crtc = new EGA(this.crtc, memo.add, memo.ram);
                    this.cpu.peripherals.push(new EMS(memo.add));
                    MACHINE = 1;
                    CPU_186 = 1;
                }
                this.cpu.peripherals.push(this.crtc);
                memo.setChipset(this.crtc, this.ppi);
                break;
            default: throw new Error(`invalid cpu: ${type}`);
        }
        memo.CPU = this; // set CPU reference
    }
    async run() {
        this.RUN = true;
        let print = true, res;
        do {
            for (let i = 0; i < this.CPU_INSTR_CNT; i++) { // number of instructions not cycles!
                try { res = this.cpu.step(); }
                catch(exc) {
                    console.error(exc);
                    this.RUN = false;
                    break;
                }
                if (!res || (this.STOP >= 0 && this.cpu.getPC() === this.STOP)) {
                    if (res) { console.info('STOP'); this.STOP = -1; }
                    else if (!this.HLT_STOP) break;
                    else console.info('HALT');
                    this.RUN = false;
                    print = false;
                    break;
                }
                if (!this.RUN) break;
            }
            await delay(0);
        } while (this.RUN);
        if (print) console.info('stopped');
    }
    setRegisters(regs) {
        let res;
        if ((res = this.cpu.setRegisters([0, ...regs])).length > 0) throw new Error(res);
    }
    cpuStatus() {
        return this.cpu.cpuStatus();
    }
}

class MemIO {
    constructor(con, type, gsx_support = false) {
        this.con = con;
        this.ram = new Uint8Array((type < 3) ? 0x10000 : 0x100000); // 8bit: 64K, 16bit: 1M
        if (gsx_support) this.gsx = GSX(this);
        this.CPU = null; // CPU reference
    }
    rd(a) {
        return this.ram[a];
    }
    wr(a, v) {
        this.ram[a] = v;
    }
    input(p) {
        switch (p) {
            case 0x00: return (this.con.kbd.length > 0) ? 0xff : 0x00;
            case 0x01: return (this.con.kbd.length > 0) ? this.con.kbd.shift() : 0x00;
            default: throw new Error(`unknown input port: ${fmt(p)}`);
        }
    }
    output(p, v) {
        switch (p) {
            case 0x01: this.con.display(v & 0xff); break;
            default: throw new Error(`unknown output port: ${fmt(p)}`);
        }
    }
}

class CPMMemIO extends MemIO {
    constructor(con, type, gsx_support = false, con2 = null) {
        super(con, type, gsx_support);
        this.con2 = con2;                                 // second console for MP/M
        this.SEG = 49152;                                 // page size for CP/M+ and MP/M
        this.rams = [new Uint8Array(this.SEG), this.ram]; // paged RAM for CP/M+ and MP/M
        this.CPM_DRIVES = [                               // disk drives
            null, // A: (8" IBM SD)      CP/M 2.2, CP/M 3.0, MP/M
            null, // B: (8" IBM SD)      CP/M 2.2, CP/M 3.0, MP/M
            null, // C: (8" IBM SD)      CP/M 2.2, CP/M 3.0, MP/M
            null, // D: (8" IBM SD)      CP/M 2.2, CP/M 3.0, MP/M
            null, // none
            null, // none
            null, // none
            null, // none
            null, // I: (4Mb harddisk)                       MP/M
            null, // J: (4Mb harddisk)                       MP/M
            null, // K: (4Mb harddisk)
            null, // L: (4Mb harddisk)
            null, // none
            null, // none
            null, // none
            null  // P: (512Mb harddisk)                     MP/M
        ];
        this.dskstat = 0; // disk parameters
        this.iocount = 0;
        this.drv = 0;
        this.trk = 0;
        this.sec = 0;
        this.dma = 0;
        this.printer = ''; // printer
        this.tape = '';    // tape
        this.tapepos = 0;
        this.puncher = ''; // puncher
        this.TIMER_RUN = false;
        this.bank = 1; // current memory bank
        this.clkcmd = 0;
        [this.clkdata, this.clktemp] = this.dateTime();
        this.sconsole = ''; // console buffer
        this.ccopy = false; // console buffer enabled
        this.wfname = null; // work file full name (set for one R/O automatically updated file)
        this.wfdnme = null; // work file name
        this.wfdrv = -1;    // work file drive
        this.wfdate = null; // work file modified date
    }
    dateTime() {
        let date; // temp = (date - (8 years) + (1 day)) / day
        return [date = new Date(), ((date.getTime() - 252442799999 + 86400000) / 86400000) | 0];
    }
    async timer10(value) {
        if (value !== 1) { this.TIMER_RUN = false; return; }
        else if (this.TIMER_RUN) return;
        this.TIMER_RUN = true;
        this.CPU.cpu.setInterrupt(7); // one time for interrupt test
        while (this.TIMER_RUN) {
            await delay(100);
            if (this.CPU.RUN) this.CPU.cpu.setInterrupt(7);
        }
    }
    rd(a) {
        return (this.bank == 1 || a >= this.SEG) ? this.ram[a] : this.rams[this.bank][a];
    }
    wr(a, v) {
        if (this.bank == 1 || a >= this.SEG) this.ram[a] = v;
        else this.rams[this.bank][a] = v;
    }
    input(p) {
        switch (p) {
            case 0x00: return (this.con.kbd.length > 0) ? 0xff : 0x00;                        // console status
            case 0x01: return (this.con.kbd.length > 0) ? this.con.kbd.shift() & 0x7f : 0x00; // console data
            case 0x02: return 0x1a;                                                           // printer status
            case 0x04: return 0xff;                                                           // auxilary status
            case 0x05:                                                                        // paper tape (aux)
                return (this.tapepos >= this.tape.length) ? 0x1a : this.tape.charCodeAt(this.tapepos++) & 0xff;
            case 0x0a: return this.drv;                                                       // fdc drive
            case 0x0b: return this.trk;                                                       // fdc track
            case 0x0c: return this.sec & 0x00ff;                                              // fdc sector low
            case 0x0d: return (this.iocount === 0) ? 0xff : 0x00;                             // fdc command
            case 0x0e: return this.dskstat;                                                   // fdc status
            case 0x0f: return this.dma & 0x00ff;                                              // dma address low
            case 0x10: return (this.dma & 0xff00) >>> 8;                                      // dma address high
            case 0x11: return (this.sec & 0xff00) >>> 8;                                      // fdc sector high
            case 0x1a:                                                                        // clock data
                let res;
                switch (this.clkcmd) {
                    case 0:                                         // sec
                        [this.clkdata, this.clktemp] = this.dateTime();
                        res = this.clkdata.getSeconds();
                        break;
                    case 1: res = this.clkdata.getMinutes(); break; // min
                    case 2: res = this.clkdata.getHours(); break;   // hrs
                    case 3: return this.clktemp & 0xff;             // days low
                    case 4: return (this.clktemp >>> 8) & 0xff;     // days high
                    default: return 0x1a;                           // CTRL-Z to simulate EOF
                }
                const tens = (res / 10) | 0,
                      units = (res % 10) | 0;
                return (tens << 4) | units;
            case 0x28: return this.con2 ? (this.con2.kbd.length > 0) ? 0x03 : 0x02 : 0x00;    // console 1 status
            case 0x29: return (this.con2.kbd.length > 0) ? this.con2.kbd.shift() & 0x7f : 0x02;
            case 0x2a: return 0x00;                                                           // console 2 status
            case 0x2c: return 0x00;                                                           // console 3 status
            case 0x2e: return 0x00;                                                           // console 4 status
            default: throw new Error(`unknown input port: ${fmt(p)}`);
        }
    }
    output(p, v) {
        switch (p) {
            case 0x00:                                                                        // tests data
                if (v === 0x0a) { console.log(); break; }
                else if (v === 0x0d) break;
                console.log(String.fromCharCode(v), console.NB);
                break;
            case 0x01:                                                                        // console data
                v &= 0xff;
                this.con.display(v);
                if (this.ccopy) this.sconsole += String.fromCharCode(v);                      // keep screen data
                break;
            case 0x03: this.printer += String.fromCharCode(v); break;                         // printer data
            case 0x04: if (v & 0x01) this.tapepos = 0; break;                                 // rewind tape (aux)
            case 0x05: this.puncher += String.fromCharCode(v); break;                         // paper puncher (aux)
            case 0x0a: this.drv = v & 0xff; break;                                            // fdc drive
            case 0x0b: this.trk = v & 0xff; break;                                            // fdc track
            case 0x0c: this.sec = (this.sec & 0xff00) | (v & 0xff); break;                    // fdc sector low
            case 0x0d:                                                                        // fdc command
                if (v !== 0 && v !== 1) this.dskstat = 7; // illegal command
                else {
                    this.iocount++;
                    (async () => {
                        try {
                            const dd = this.CPM_DRIVES[this.drv];
                            if (dd === null || dd === undefined) this.dskstat = 1; // illegal drive
                            else {
                                if (this.wfname !== null && this.wfdrv === this.drv && // work file set
                                        v === 0 && this.trk === 2 && this.sec === 1) { // read first DIR sector
                                    const hndl = await preLoadFile(this.wfname);       // check modified time
                                    if (hndl.headers.get('Last-Modified') > this.wfdate)
                                        dd.diskRW(this.wfdnme, new Uint8Array(await hndl.arrayBuffer()));
                                }
                                this.dskstat = dd.transfer(this.trk, this.sec, this.dma, v === 0, this);
                            }
                        } catch(e) {
                            console.error(e.stack);
                        }
                        this.iocount--;
                    })();
                }
                break;
            case 0x0f: this.dma = (this.dma & 0xff00) | (v & 0xff); break;                    // dma address low
            case 0x10: this.dma = (this.dma & 0x00ff) | ((v & 0xff) << 8); break;             // dma address high
            case 0x11: this.sec = (this.sec & 0x00ff) | ((v & 0xff) << 8); break;             // fdc sector high
            case 0x14:                                                                        // mmu init
                if (v > 8) throw new Error(`invalid memory banks: ${v}`);
                while (v-- > 2) this.rams.push(new Uint8Array(this.SEG));
                break;
            case 0x15:                                                                        // mmu select
                if (v >= this.rams.length) throw new Error(`invalid memory bank: ${v}`);
                this.bank = v & 0xff;
                break;
            case 0x19: this.clkcmd = v & 0xff; break;                                         // clock command
            case 0x1b: this.timer10(v); break;                                                // 10ms interrupt timer
            case 0x29: this.con2.display(v & 0xff); break;
            case 0xdd: this.gsx(this.con, v); break;                                          // GSX support
            default: throw new Error(`unknown output port: ${fmt(p)}`);
        }
    }
    setTape(value) {
        this.tape = value; this.tapepos = 0;
    }
    setBank(value) {
        if (value >= this.rams.length) throw new Error(`invalid memory bank: ${value}`);
        this.bank = value;
    }
    setCopy(flag) {
        this.ccopy = flag; this.sconsole = '';
    }
    reset() {
        this.timer10(0); // stop timer
        this.ram.fill(0x00);
        this.rams.length = 2; this.rams[0].fill(0x00);
        this.dskstat = 0; this.iocount = 0; this.drv = 0; this.trk = 0; this.sec = 0; this.dma = 0;
        this.printer = ''; this.tape = ''; this.tapepos = 0; this.puncher = '';
        this.bank = 1; this.clkcmd = 0; [this.clkdata, this.clktemp] = this.dateTime();
        this.sconsole = '';
    }
}

class Emulator {
    constructor(cpu, mem, type) {
        this.CPU = cpu;
        this.memo = mem;
        this.SIM_DEBUG = null; // address - name assoc. string (addr: name[ \n])
        this.D_SPC = '';       // display header space  (8bit CPU: empty,  16bit CPU: one space)
        this.D_WDT = 4;        // display address width (8bit CPU: 4,      16bit CPU: 5)
        this.D_AMS = 0xffff;   // display address mask  (8bit CPU: 0xffff, 16bit CPU: 0xfffff)
        this.D_CMD = 3;        // display command pad   (8bit CPU: 3,      16bit CPU: 6)
        this.D_PRF = 'PC: ';   // display regs prefix   (8bit CPU: 'PC: ', 16bit CPU: '\n')
        this.D_STT = 0xfffe;   // display stack top     (8080 and Z80: 0xfffe, 6502: 0x01fe, 8086: 0xffffe)
        this.D_DCW = 300;      // display debug width   (8bit CPU: 300,    16bit CPU: 430)
        this.D_DRW = 200;      // display debug rg wdth (8bit CPU: 200,    16bit CPU: 230)
        if (type === 2) this.D_STT = 0x01fe; // for 6502
        else if (type > 2) {                 // for 8086 and 80186
            this.D_SPC = ' '; this.D_WDT = 5; this.D_AMS = 0xfffff; this.D_CMD = 6; this.D_PRF = '\n';
            this.D_STT = 0xffffe; this.D_DCW = 430; this.D_DRW = 230;
        }
        this.watches = []; // debug watches
        this.dbgw = null;  // debug window
    }
    loadBin(data, start, mem) {
        if (mem === undefined) mem = this.memo;
        const n = data.length;
        for (let i = 0; i < n; i++) mem.wr(start++, data[i]);
        return n;
    }
    loadHex(text, start, mem) {
        const lines = text.split(/[\r\n]+/);
        let length = 0;
        for (let i = 0, n = lines.length; i < n; i++) {
            let line = lines[i].trim(), idx;
            if ((idx = line.indexOf(';')) >= 0) line = line.substr(0, idx).trim();
            if (line.length === 0) continue;
            line = line.replaceAll(' ', '');
            const code = [];
            let count, s;
            idx = line.indexOf(':');
            if (idx >= 0)
                if (idx === 0) { // intel hex
                    count = pi(line.substr(1, 2));
                    start = pi(line.substr(3, 4));
                    s = 9;       // skip fill byte
                } else {         // list hex
                    start = pi(line.substr(0, idx));
                    s = idx + 1;
                    count = ((line.length - s) / 2) | 0;
                }
            else {               // plain hex
                count = (line.length / 2) | 0;
                s = 0;
            }
            for (let j = 0; j < count; j++) {
                code.push(pi(line.substr(s, 2)));
                s += 2;
            }
            length += this.loadBin(code, start, mem);
            start += count;
        }
        return length;
    }
    printMem(a, lines = 16, mem, logger = console.log) {
        if (mem === undefined) mem = this.memo;
        logger(`Addr   ${this.D_SPC}0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  ASCII           `);
        for (let i = 0; i < lines; i++) {
            let s = `${fmt(a, this.D_WDT)}: `, // addr
                s2 = '';                       // ascii
            for (let j = 0; j < 16; j++) {
                const c = mem.rd(a + j);
                if (c === undefined) break;
                s += `${fmt(c)} `;
                s2 += (c >= 0x20 && c <= 0x7f) ? String.fromCharCode(c) : '.';
            }
            logger(s, s2);
            a = (a + 16) & this.D_AMS;
        }
        return a;
    }
    disassemble1(a) {
        if (a === undefined) a = this.CPU.cpu.getPC();
        const r = [],
              d = this.CPU.cpu.disassembleInstruction(a);
        r.push(fmt(a, this.D_WDT));
        r.push(': ');
        let end = d[0] - a;
        for (let i = 0; i < end; i++) {
            const c = this.memo.rd(a + i);
            if (c === undefined) break;
            r.push(fmt(c));
        }
        while (end++ < this.D_CMD) r.push('  ');
        r.push(' ');
        r.push(d[1]);
        return [d[0], r.join('')];
    }
    printAsm(a, lines = 16, logger = console.log) {
        for (let i = 0; i < lines; i++) {
            const r = this.disassemble1(a);
            let sim = '', m;
            if (this.SIM_DEBUG !== null) {
                m = this.SIM_DEBUG.match(`${fmt(a, this.D_WDT)}: (.+?)[ \n]`);
                if (m !== null) sim = `${' '.padStart(28 - r[1].length, ' ')}<b>${m[1]}</b>`;
            }
            logger(r[1] + sim);
            a = r[0] & this.D_AMS;
        }
        return a;
    }
    printRegs(logger = console.log) {
        const regs = this.CPU.cpuStatus().replaceAll('|', ' ').replaceAll('#', '\n');
        logger(`${regs} ${this.D_PRF}${this.disassemble1(this.CPU.cpu.getPC())[1]}`);
    }
    debug_find(wnd, addr) {
        addr = fmt(addr, this.D_WDT);
        const nodes = wnd[0].childNodes;
        for (let i = 0, n = nodes.length; i < n; i++) {
            const node = nodes[i];
            if (node.innerText.startsWith(addr))
                return node;
        }
        return null;
    }
    debug_asm(wnd, addr) {
        wnd[0].innerHTML = '';
        wnd.prevNode = undefined;
        this.printAsm(addr, 75, wnd[1]);
    }
    debug_set(wnd) {
        const addr = this.CPU.cpu.getPC();
        let node = this.debug_find(wnd, addr);
        if (node === null) {
            this.debug_asm(wnd, addr);
            node = this.debug_find(wnd, addr);
        }
        if (wnd.prevNode) wnd.prevNode.style.backgroundColor = 'var(--dbgbckgrnd)';
        node.style.backgroundColor = 'var(--dbghilight)';
        const inrect = node.getBoundingClientRect(),
              outrect = wnd[0].getBoundingClientRect();
        if (inrect.top < outrect.top)
            node.scrollIntoView(true);
        else if (inrect.bottom > outrect.bottom)
            node.scrollIntoView(false);
        wnd.prevNode = node;
    }
    debug_sp() {
        let addr = this.CPU.cpu.getSP(), s = '', i = 8, dw = false;
        if (Array.isArray(addr)) {
            addr = pi(`${addr[0]}:${addr[1]}`);
            dw = true; // 16bit, double word on return stack (ip, cs)
        }
        while (i-- > 0) {
            let w = this.memo.rd(addr++) | this.memo.rd(addr++) << 8;
            if (dw) {
                if (addr > this.D_STT) break;
                w = ((this.memo.rd(addr++) | this.memo.rd(addr++) << 8) << 4) + w;
            }
            s += fmt(w, this.D_WDT) + ' ';
            if (i > 0 && i % 4 === 0) s += '\n';
            if (addr > this.D_STT) break;
        }
        return s;
    }
    debug_regs(wnd) {
        wnd[0].innerHTML = '';
        const s = this.CPU.cpuStatus();
        wnd[1](s.replaceAll('|', '\n').replaceAll('#', '\n'));
        wnd[1]();
        wnd[1](this.debug_sp());
    }
    debug_watch(wnd) {
        wnd[0].innerHTML = '';
        for (let i = 0, n = this.watches.length; i < n; i++) {
            const adr = this.watches[i], val = this.memo.rd(adr);
            wnd[1](`${fmt(adr, this.D_WDT)}: ${fmt(val)} ${val.toString(2).padStart(8, '0')}`);
        }
    }
    debug_update() {
        this.debug_set(this.dbgw);
        this.debug_regs(this.dbgw.regs);
        this.debug_watch(this.dbgw.watch);
    }
    debug(h, show = true) {
        if (show) {
            if (this.dbgw !== null) { console.error('debug active'); return; }
            const x = screen.width - this.D_DCW - 17 - this.D_DRW - 17 - 5,
                  y = 5;
            this.dbgw = console.open(x, y, this.D_DCW, h + 17,
                    'var(--dbgcolor)', 'var(--dbgbckgrnd)');
            this.dbgw.regs = console.open(x + this.D_DCW + 17, y, this.D_DRW, 116,
                    'var(--dbgcolor)', 'var(--dbgbckgrnd)');
            this.dbgw.watch = console.open(x + this.D_DCW + 17, y + 116 + 17, this.D_DRW, h - 116,
                    'var(--dbgcolor)', 'var(--dbgbckgrnd)');
            this.debug_update();
        } else {
            if (this.dbgw === null) { console.error('debug not active'); return; }
            console.close(this.dbgw.watch);
            this.dbgw.watch = null;
            console.close(this.dbgw.regs);
            this.dbgw.regs = null;
            console.close(this.dbgw);
            this.dbgw = null;
        }
    }
    stop() {
        this.CPU.RUN = false;
    }
}

class Keyboard {
    constructor(kbdElem = document.getElementsByClassName('keyboard')[0]) {
        this.kbdElem = kbdElem;
        this.fs_shift = false;
        this.fs_ctrl = false;
        this.fs_alt = false;
        this.fs_caps = false;
        const shfts = kbdElem.getElementsByClassName('kshft'),
              ctrls = kbdElem.getElementsByClassName('kctrl'),
              alts = kbdElem.getElementsByClassName('kalt');
        kbdElem.onclick = e => {
            let elem = e.target;
            if (elem.tagName === 'SPAN') elem = elem.parentNode;
            const txt = elem.innerText.replace('\n', '');
            switch (txt) {
                case 'CapsLock':
                    this.fs_caps = !this.fs_caps; this.fs_shift = this.fs_caps;
                    shfts[0].style.borderColor = shfts[1].style.borderColor = this.fs_caps ?
                            'var(--keypressed)' : 'var(--onbackground)';
                    break;
                case 'Shift':
                    this.fs_shift = !this.fs_shift;
                    shfts[0].style.borderColor = shfts[1].style.borderColor = this.fs_shift ?
                            'var(--keypressed)' : 'var(--onbackground)';
                    if (!this.fs_shift) this.fs_caps = false;
                    break;
                case 'Ctrl':
                    this.fs_ctrl = !this.fs_ctrl;
                    ctrls[0].style.borderColor = ctrls[1].style.borderColor = this.fs_ctrl ?
                            'var(--keypressed)' : 'var(--onbackground)';
                    break;
                case 'Alt':
                    this.fs_alt = !this.fs_alt;
                    alts[0].style.borderColor = alts[1].style.borderColor = this.fs_alt ?
                            'var(--keypressed)' : 'var(--onbackground)';
                    break;
                default:
                    this.kbdHandler(txt, true);
                    if (!this.fs_caps && this.fs_shift) {
                        shfts[0].style.borderColor = shfts[1].style.borderColor = 'var(--onbackground)';
                        this.fs_shift = false;
                    }
                    if (this.fs_ctrl) {
                        ctrls[0].style.borderColor = ctrls[1].style.borderColor = 'var(--onbackground)';
                        this.fs_ctrl = false;
                    }
                    if (this.fs_alt) {
                        alts[0].style.borderColor = alts[1].style.borderColor = 'var(--onbackground)';
                        this.fs_alt = false;
                    }
                    break;
            }
        };
        document.onkeydown = e => {
            e.preventDefault();
            switch (e.key) {
                case 'Shift': this.fs_shift = true; break;
                case 'Control': this.fs_ctrl = true; break;
                case 'Alt': this.fs_alt = true; break;
                default: this.kbdHandler(e.key, false); break;
            }
        };
        document.onkeyup = e => {
            e.preventDefault();
            switch (e.key) {
                case 'Shift': this.fs_shift = false; break;
                case 'Control': this.fs_ctrl = false; break;
                case 'Alt': this.fs_alt = false; break;
            }
        };
    }
    kbdHandler(txt, soft) {
        let val = null;
        switch (txt) {
            case 'Escape':
            case 'Esc': val = 27; break;
            case 'F1':
            case 'F2':
            case 'F3':
            case 'F4':
            case 'F5':
            case 'F6':
            case 'F7':
            case 'F8':
            case 'F9':
            case 'F10':
            case 'F11':
            case 'F12': break;
            case 'Backspace': val = 8; break;
            case 'Tab': val = 9; break;
            case 'Enter': val = 13; break;
            case ' ':
            case 'Space': val = 32; break;
            case 'Insert': val = 15; break;
            case 'PageUp':
            case 'PgUp': val = 18; break;
            case 'Delete':
            case 'Del': val = 127; break;
            case 'Home':
            case 'End': val = 2; break;
            case 'PageDown':
            case 'PgDn': val = 3; break;
            case 'ArrowLeft':
            case '\u2190': val = 19; break; // left arrow
            case 'ArrowUp':
            case '\u2191': val = 5; break;  // up arrow
            case 'ArrowRight':
            case '\u2192': val = 4; break;  // right arrow
            case 'ArrowDown':
            case '\u2193': val = 24; break; // down arrow
            default:
                if (txt.length > 1) val = txt.charCodeAt(this.fs_shift ? 0 : 1);
                else {
                    if (soft && !this.fs_shift) txt = txt.toLowerCase();
                    val = txt.charCodeAt(0);
                }
                break;
        }
        if (val !== null) {
            val &= 0xff;
            if (this.fs_ctrl) {
                if (val >= 0x60) val -= 0x60;
                if (val >= 0x40) val -= 0x40;
            }
        }
        return val;
    }
}

class Monitor {
    constructor(emu, debug_height = 450, logger = console.log) {
        this.emu = emu;
        this.addr = 0;
        this.debug_height = debug_height;
        this.logger = logger;
    }
    async exec(command) {
        const parms = command.split(/[\s\t]+/);
        await this.handler(parms, parms[0]);
    }
    async handler(parms, cmd) {
        let tmp, len, adr, idx, hex;
        switch (cmd) {
            case '':
                try { this.emu.CPU.cpu.step(); } catch(exc) { console.error(exc); break; }
                this.addr = this.emu.CPU.cpu.getPC();
                if (this.emu.dbgw !== null) {
                    this.emu.debug_update();
                    break;
                }
            case 'x':
                if (parms.length > 1 && (tmp = this.emu.CPU.setRegisters(parms)).length > 0) console.error(tmp);
                else if (this.emu.dbgw === null) this.emu.printRegs(this.logger);
                else {
                    this.emu.debug_set(this.emu.dbgw);
                    this.emu.debug_regs(this.emu.dbgw.regs);
                }
                break;
            case 'g':
                len = parms.length;
                if (len > 1 && (tmp = parms[1]) !== '-') this.emu.CPU.cpu.setPC(pi(tmp));
                if (len > 2) this.emu.CPU.STOP = pi(parms[2]);
                this.emu.CPU.run();
                console.info('running...');
                break;
            case 'step':
                this.emu.CPU.STOP = ((parms.length > 1) ? pi(parms[1]) : this.emu.disassemble1()[0]) & this.emu.D_AMS;
                if (this.emu.dbgw === null) this.emu.CPU.run();
                else {
                    await this.emu.CPU.run();
                    this.emu.debug_update();
                }
                break;
            case 'debug':
                this.emu.debug(this.debug_height, true);
                break;
            case 'quit':
                this.emu.debug(this.debug_height, false);
                break;
            case 'refresh':
                if (this.emu.dbgw === null) { console.error('debug not active'); break; }
                this.emu.dbgw[0].innerHTML = '';
                this.emu.debug_update();
                break;
            case 'wadd':
                if (parms.length < 2) { console.error('missing: adr [adr ...]'); break; }
                for (let i = 1, n = parms.length; i < n; i++)
                    if (this.emu.watches.indexOf(tmp = pi(parms[i])) < 0) this.emu.watches.push(tmp);
                if (this.emu.dbgw !== null) this.emu.debug_watch(this.emu.dbgw.watch);
                break;
            case 'wrem':
                if (parms.length < 2) { console.error('missing: adr [adr ...]'); break; }
                for (let i = 1, n = parms.length; i < n; i++)
                    if ((idx = this.emu.watches.indexOf(pi(parms[i]))) >= 0) this.emu.watches.splice(idx, 1);
                if (this.emu.dbgw !== null) this.emu.debug_watch(this.emu.dbgw.watch);
                break;
            case 'd':
                if (parms.length > 1) this.addr = pi(parms[1]);
                this.addr = this.emu.printMem(this.addr, undefined, undefined, this.logger);
                break;
            case 'l':
                if (parms.length > 1) this.addr = pi(parms[1]);
                this.addr = this.emu.printAsm(this.addr, undefined, this.logger);
                break;
            case 'm':
                if (parms.length < 3) console.error('missing: adr b [b ...]');
                else this.logger(this.emu.loadBin(parms.slice(2).map(i => pi(i) & 0xff), pi(parms[1]) & this.emu.D_AMS));
                break;
            case 'r':
                if ((len = parms.length) < 2) { console.error('missing: [a=100] fn [h=0]'); break; }
                idx = 1;
                try { adr = pi(parms[1]) & this.emu.D_AMS; idx++; } catch(exc) { adr = 0x100; }
                if (len < idx + 1) { console.error('missing: [a=100] fn [h=0]'); break; }
                hex = (len > idx + 1) ? parms[idx + 1] === '1' : false;
                tmp = await loadFile(parms[idx], hex);
                this.logger(hex ? this.emu.loadHex(tmp, adr) : this.emu.loadBin(tmp, adr));
                break;
            case 'w':
                if (parms.length < 3) { console.error('missing: a1 a2'); break; }
                adr = pi(parms[1]) & this.emu.D_AMS;
                len = pi(parms[2]) & this.emu.D_AMS;
                if (adr > len) { console.error(`end address: ${len.toString(16)} < start: ${adr.toString(16)}`); break; }
                tmp = new Uint8Array(len - adr + 1);
                for (let i = adr, a = 0; i <= len; i++) tmp[a++] = this.emu.memo.rd(i);
                downloadFile('block.bin', tmp);
                break;
            case 'cls':
                console.clear();
                break;
            default: console.error(`invalid command: ${cmd}`); break;
        }
    }
}

class CPMMonitor extends Monitor {
    constructor(emu, debug_height, logger) {
        super(emu, debug_height, logger);
    }
    getDisk(pms, n, er, fg) {             // disk IO command helper
        if (pms.length < n) { console.error(er); return; }
        const dn = pi(pms[1], false);
        if (dn >= this.emu.memo.CPM_DRIVES.length) { console.error(`invalid drive num: ${dn}`); return; }
        if (!fg) return dn;
        const dd = this.emu.memo.CPM_DRIVES[dn];
        if (dd === undefined || dd === null) { console.error(`invalid drive: ${dn}`); return; }
        return dd;
    }
    async handler(parms, cmd) {
        switch (cmd) {
            case 'read':                  // read file
                const r_drive = this.getDisk(parms, 3, 'missing: drv fname', true);
                if (r_drive === undefined) break;
                let r_fn;
                const r_buf = r_drive.diskRW(r_fn = parms[2]);
                if (r_buf !== null) downloadFile(r_fn.toUpperCase(), r_buf);
                else console.log(`file ${r_fn} not found or empty`);
                break;
            case 'write':                 // write file
                const w_drive = this.getDisk(parms, 3, 'missing: drv fname [R/O=0]', true);
                if (w_drive === undefined) break;
                let w_fn, w_idx, w_nn;
                const hndl = await preLoadFile(w_fn = parms[2]),
                      w_buf = new Uint8Array(await hndl.arrayBuffer());
                w_nn = ((w_idx = w_fn.lastIndexOf('/')) >= 0) ? w_fn.substring(w_idx + 1) : w_fn;
                w_drive.diskRW(w_nn, w_buf);
                console.log(w_buf.length);
                if (parms.length > 3 && parms[3] === '1') { // set R/O working file
                    this.emu.memo.wfname = w_fn;
                    this.emu.memo.wfdnme = w_nn;
                    this.emu.memo.wfdrv = pi(parms[1], false);
                    this.emu.memo.wfdate = hndl.headers.get('Last-Modified');
                }
                break;
            case 'bank':                  // get/set active memory bank
                if (parms.length < 2) this.logger(this.emu.memo.bank);
                else this.emu.memo.setBank(pi(parms[1]));
                break;
            case 'copy':                  // console output snapshot
                if (parms.length < 2) {
                    console.log('"',this.emu.memo.sconsole,'"');
                    this.emu.memo.setCopy(false);
                }
                else this.emu.memo.setCopy(parms[1] === '1');
                break;
            case 'on':                    // start emulator (0 - do not load disks)
                if (parms.length < 2) { console.error('missing: ver (0=CP/M 2.2|1=CP/M 3.0|2=MP/M II'); break; }
                const version = pi(parms[1]);
                this.emu.memo.reset();
                if (version > 0) this.emu.memo.setBank(0); // bank 0 must be active for CP/M+ and MP/M
                this.emu.CPU.HLT_STOP = version < 2;       // no stop on HALT for MP/M (interrupt based)
                let boot_err;                              // boot loader
                if ((boot_err = this.emu.memo.CPM_DRIVES[0].transfer(0, 1, 0x0000, true, this.emu.memo)) !== 0)
                    console.error(`boot error: ${boot_err}`);
                else { this.emu.CPU.cpu.reset(); this.emu.CPU.run(); }
                break;
            default: await super.handler(parms, cmd); break;
        }
    }
}

async function main() {
    class Kbd extends Keyboard {
        constructor(con, monitor) {
            super();
            this.con = con;
            this.monitor = monitor;
        }
        kbdHandler(txt, soft) {
            const val = super.kbdHandler(txt, soft);
            if (val !== null) {
                if (val === 14) {
                    this.monitor.emu.stop();
                    this.monitor.logger('\n');
                    this.monitor.exec('x');
                    return;
                }
                this.con.kbd.push(val);
                if (!this.monitor.emu.CPU.RUN) {
                    this.con.display(val);
                    if (val === 8) { this.con.kbd.pop(); this.con.kbd.pop(); }
                    else if (val === 13) {
                        this.con.print('^[2K'); this.con.kbd.pop();
                        const cmd = this.con.kbd.reduce((str, val) => str + String.fromCharCode(val), '');
                        this.con.kbd.length = 0;
                        this.monitor.exec(cmd);
                    }
                }
            }
        }
    }
    const amber = '#b38000', // amber monitor
          green = '#36bf00', // green monitor
          blue = '#a5a4b3',  // blue (white) monitor
          con = await VT_100('scr', {COLORS: [
              '#282828', '#0000aa', '#00aa00', '#00aaaa', '#aa0000', '#aa00aa', '#aa5500', amber,
              '#555555', '#5555ff', '#55ff55', '#55ffff', '#ff5555', '#ff55ff', '#ffff55', '#ffffff'
          ], FONT_WIDTH: 10, FONT_HEIGHT: 20, SCR_HEIGHT: 24, FONT_G0: 'VT220'}),
          mem = new CPMMemIO(con, 1, true),
          cpu = new Cpu(mem, 1),
          emu = new Emulator(cpu, mem, 1),
          mon = new CPMMonitor(emu, undefined, (...args) => con.print(args.join(' ').replace('\n', '~') + '~')),
          kbd = new Kbd(con, mon);
//    mem.ram.set(await loadFile('sargon.bin'), 0);
//    cpu.setRegisters(['pc', '2372']);
    mem.CPM_DRIVES[0] = await CPMDisk('../cpm/mpma.cpm');
    mem.CPM_DRIVES[1] = await CPMDisk('../cpm/mpmb.cpm');
//    mem.CPM_DRIVES[0] = await CPMDisk('../cpm/cpm3a.cpm');
//    mem.CPM_DRIVES[1] = await CPMDisk('../cpm/cpm3b.cpm');
//    mem.CPM_DRIVES[0] = await CPMDisk('../cpm/cpma.cpm');
//    mem.CPM_DRIVES[1] = await CPMDisk('../cpm/cpmb_turbo.cpm');
//    mem.CPM_DRIVES[2] = await CPMDisk('../cpm/gsx/gsx.cpm');
//    mem.CPM_DRIVES[3] = await CPMDisk('../cpm/cpma.cpm');
mem.CPM_DRIVES[8] = await CPMDisk('../../../../emu8080/mpm/hd-mpmsrc.dsk');
    mon.exec('on 2');
}

(async () => {
    try {
        await main();
    } catch(e) {
        console.error(e.stack);
    }
})();
    </script>
</body>
</html>
